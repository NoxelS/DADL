\documentclass{article}


% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[ngerman]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[a4paper,top=3cm,bottom=3cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

\usepackage{bbold}
\usepackage{eurosym}
\usepackage[markup=nocolor]{changes}
\usepackage{listings,xcolor}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage[figurename=Grafik]{caption}
\usepackage[section]{placeins}
\usepackage{siunitx}
\usepackage{lscape}
\usepackage{pdfpages}
\usepackage{xcolor}
\usepackage{dsfont}
\usepackage{esvect}
\usepackage{tabularx}
\usepackage{gauss}
\usepackage{float}
\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{lipsum}
\usepackage{mdframed}

\usepackage{fancyhdr}

% Übungsnummer wird hier angepasst
\newcommand{\ubungsnummer}{1}


\pagestyle{fancy}
\fancyhead{} % clear all header fields
\fancyhead[L]{DADL: Übung \ubungsnummer}
\fancyhead[C]{\today}
\fancyhead[R]{Noel Schwabenland}
\fancyfoot{} % clear all footer fields
\fancyfoot[R]{\thepage}


\newcommand{\levi}{\epsilon_{ijk}}
\newcommand{\grad}{\text{grad}}
\newcommand{\divergenz}{\text{div}}
\newcommand{\rot}{\text{rot}}

\title{Data Analysis und Deep Learning: Übung \ubungsnummer}
\author{Noel Schwabenland}

\begin{document}

\maketitle
\thispagestyle{fancy}

\section*{Übung 1-253: \textit{\textmd{Baumstrukturen, Linearisierung, Suchbäume}}}
\subsection*{1.}
\subsection*{a)}
\begin{tikzpicture}[
	every node/.style = {minimum width = 1em, draw, circle},
	level 1/.style ={sibling distance = 3cm},
	level 2/.style ={sibling distance = 2cm},
	level 3/.style ={sibling distance = 1cm}]
\node{A}
child{
	node{B}
	child{
    	node{C}
    }
	child{
    	node{D}
    }
}
child{
	node{E}
	child{
    	node{F}
    }
	child{
    	node{G}
    }
};
\end{tikzpicture}
\subsection*{b)}
\begin{tikzpicture}[
	every node/.style = {minimum width = 1em, draw, circle},
	level 1/.style ={sibling distance = 3cm},
	level 2/.style ={sibling distance = 2cm},
	level 3/.style ={sibling distance = 1cm}]
\node{A}
child{
	node{B}
	child{
    	node{C}
    	child{
        	node{D}
        	child{
            	node{E}
            }
        }
    }
};
\end{tikzpicture}
\subsection*{c)}
\begin{tikzpicture}[
	every node/.style = {minimum width = 0.75em, draw, circle},
	level 1/.style ={sibling distance = 3cm},
	level 2/.style ={sibling distance = 1cm},
	level 3/.style ={sibling distance = 0.75cm}]
\node{X}
child{
	node{X}
	child{
    	node{X}
    }
    child{
    	node{X}
		child{
    	    node{X}
        }
		child{
    	    node{X}
    	    child{
    	        node{X}
            }
        }
    }
}
child{
	node{X}
	child{
    	node{X}
		child{
    	    node{X}
        }
        child{
    	    node{X}
        }
    }
    child{
    	node{X}
    }
};
\end{tikzpicture}
\subsection*{d)}
Das selbe wie in c).
\subsection*{2.}
Die Listen sind:
Pre-Order:      [62, 35, 22, 7, 12, 31, 43, 39, 59, 67, 93] \\
Infix-Order:    [7, 12, 22, 31, 35, 39, 43, 59, 62, 67, 93] \\
Tree (post):    [12, 7, 31, 22, 39, 59, 43, 35, 93, 67, 62] \\
\begin{tikzpicture}[
	every node/.style = {minimum width = 1em, draw, circle},
	level 1/.style ={sibling distance = 3cm},
	level 2/.style ={sibling distance = 2cm},
	level 3/.style ={sibling distance = 1cm}]
\node{62}
child{
	node{35}
	child{
		node{22}
		child{
			node{7}
			child{
				node{12}
			}
		}
		child{
			node{31}
		}
	}
	child{
		node{43}
		child{
			node{39}
		}
		child{
			node{59}
		}
	}
}
child{
	node{67}
	child{
		node{93}
	}
};
\end{tikzpicture}

\subsection*{3.}
\subsection*{4.}
Für Binäre Suchbäume ist folgende rekursive Methode ausreichend
\begin{verbatim}
    def findElement(self, target, n=0):
        if self.data == target:
            return (target, n)
        else:
            n += 1
            return self.lS.findElement(target, n) if target <= self.data else self.rS.findElement(target, n)
        return None
\end{verbatim}
\subsection*{5.}
\subsection*{a)}
\begin{tikzpicture}[
	every node/.style = {minimum width = 1em, draw, circle},
	level 1/.style ={sibling distance = 3cm},
	level 2/.style ={sibling distance = 2cm},
	level 3/.style ={sibling distance = 1cm}]
\node{12}
child{
	node{8}
	child{
		node{4}
	}
	child{
		node{11}
		child{
			node{10}
		}
	}
}
child{
	node{17}
	child{
		node{15}
	}
	child{
		node{20}
	}
};
\end{tikzpicture}
\subsection*{b)}
\begin{tikzpicture}[
	every node/.style = {minimum width = 1em, draw, circle},
	level 1/.style ={sibling distance = 3cm},
	level 2/.style ={sibling distance = 2cm},
	level 3/.style ={sibling distance = 1cm}]
\node{15}
child{
	node{8}
}
child{
	node{16}
	child{
		node{19}
		child{
			node{20}
			child{
				node{22}
				child{
					node{24}
				}
			}
		}
	}
};
\end{tikzpicture}
\subsection*{c)}
\begin{tikzpicture}[
	every node/.style = {minimum width = 1em, draw, circle},
	level 1/.style ={sibling distance = 3cm},
	level 2/.style ={sibling distance = 2cm},
	level 3/.style ={sibling distance = 1cm}]
\node{31}
child{
	node{12}
	child{
		node{7}
	}
	child{
		node{22}
	}
}
child{
	node{59}
	child{
		node{39}
		child{
			node{35}
		}
		child{
			node{43}
		}
	}
	child{
		node{67}
		child{
			node{62}
		}
		child{
			node{93}
		}
	}
};
\end{tikzpicture}
\subsection*{6.}
\subsection*{a)}
\begin{verbatim}
    list =  [1000,500,1500,250,750,1250,1750,125,375,625,875,1125,1375,1625,1875]
\end{verbatim}
\begin{tikzpicture}[
	every node/.style = {minimum width = 1em, draw, circle},
	level 1/.style ={sibling distance = 6cm},
	level 2/.style ={sibling distance = 3cm},
	level 3/.style ={sibling distance = 1cm}]
\node{1000}
child{
	node{500}
	child{
		node{250}
		child{
			node{125}
		}
		child{
			node{375}
		}
	}
	child{
		node{750}
		child{
			node{625}
		}
		child{
			node{875}
		}
	}
}
child{
	node{1500}
	child{
		node{1250}
		child{
			node{1125}
		}
		child{
			node{1375}
		}
	}
	child{
		node{1750}
		child{
			node{1625}
		}
		child{
			node{1875}
		}
	}
};
\end{tikzpicture}
\subsection*{b)}
\begin{verbatim}
    list = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]
\end{verbatim}
\subsection*{7.}
Methode auf einer \verb"BinarySortedNode"
\begin{verbatim}
    def insertSearchElement(self, value):
        if value > self.data:
            if self.rS:
                self.rS.insertSearchElement(value)
            else:
                self.rS = BinarySortedNode(value)
        elif value <= self.data:
            if self.lS:
                self.lS.insertSearchElement(value)
            else:
                self.lS = BinarySortedNode(value)
\end{verbatim}
\subsection*{8.}

\subsection*{9.}
Worst-Case: $\mathcal O(n)$ (sortierte Zahlenfolge 6)b))\\
Best-Case $\mathcal O(log(n))$ (6)a)) 


\end{document}
